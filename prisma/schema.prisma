// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider     = "mysql"
    // NOTE: When using postgresql, mysql or sqlserver, uncomment the @db.Text annotations in model Account below
    // Further reading:
    // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
    // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
    url          = env("DATABASE_URL")
    relationMode = "prisma"
}

enum StatusType {
    ACTIVE
    INACTIVE
    SUSPENDED
}
model User {
    id        String    @id @default(cuid())
    password  String
    firstName String
    lastName  String
    email     String    @unique
    phoneNumber String // ADD
    statusType StatusType 
    isSignedUpPromos Boolean
    homeAddress  String
    homeCity     String 
    homeState    String 
    homeZipCode  String 
    Account   Account[]
    Session   Session[]
    paymentCards PaymentCard[] // max 3?
}

// Necessary for Next auth
model Account { // TODO: DELETE WHEN USE DELETES
    id                String  @id @default(cuid())
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String? // @db.Text
    access_token      String? // @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? // @db.Text
    session_state     String?
    user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId]) // I think this needs to be changed
}

model Session { // TODO: DELETE WHEN USER DELETES
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

model Movie {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    title     String
    category  String // if we want this to be a String[] we need to change our database type
    cast      String
    director  String
    producer  String
    synopsis  String
    Review    Review[]
}

model Review {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    rating    Int
    title     String
    content   String
    author    String // this is the userID of creator of this
    movieId   String
    Movie     Movie    @relation(fields: [movieId], references: [id])
}

model Show {
    id                  String       @id @default(cuid())
    createdAt           DateTime     @default(now())
    updatedAt           DateTime     @updatedAt
    showDate            DateTime
    showTime            DateTime
    showDurationMinutes Int
    showRoom            ShowRoom     @relation(fields: [showRoomId], references: [id])
    showRoomId          String
    SeatInShow          SeatInShow[]
}

model ShowRoom {
    id             String   @id @default(cuid())
    createdAt      DateTime @default(now())
    updatedAt      DateTime @updatedAt
    numberOfSeats  Int
    name           String
    currentShowing Show[]
    seats          Seat[]
}

model Seat {
    seatNumber  Int
    isOccupied  Boolean
    doesRecline Boolean      @default(false)
    showRoomId  String
    ShowRoom    ShowRoom     @relation(fields: [showRoomId], references: [id])
    SeatInShow  SeatInShow[]

    @@id(fields: [showRoomId, seatNumber])
}

model SeatInShow {
    show Show @relation(fields: [showId], references: [id])
    seat Seat @relation(fields: [seatShowRoomId, seatNumber], references: [showRoomId, seatNumber])

    isOccupied     Boolean
    showId         String
    seatShowRoomId String
    seatNumber     Int
    Ticket         Ticket[]

    @@id(fields: [showId, seatNumber])
}

enum TicketType {
    ADULT
    SENIOR
    CHILD
}

model Ticket {
    id    String     @id @default(cuid())
    price Float
    type  TicketType

    seatInShow SeatInShow @relation(fields: [showId, seatNumber], references: [showId, seatNumber])
    showId     String
    seatNumber Int
    Booking    Booking?   @relation(fields: [bookingId], references: [id])
    bookingId  String?
}

model Booking {
    id                String   @id @default(cuid())
    tickets           Ticket[]
    bookingFee        Float
    tax               Float
    totalPrice        Float
    promoDiscount     Float
    isPaymentComplete Boolean
}

enum CardType {
  VISA
  MASTERCARD
  AMEX
  DISCOVER
}
model PaymentCard { 
    id              String @id @default(cuid()) // also acts as index
    cardNumber      String 
    cardType        CardType
    expirationMonth Int 
    expirationYear  Int
    billingAddress  String
    billingCity     String 
    billingState    String 
    billingZipCode  String 
    userId          String 
    User            User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Promotion {
    id String @id @default(cuid())

    title       String
    description String
    discount    Float
    code        String
    startDate   DateTime
    endDate     DateTime
}
